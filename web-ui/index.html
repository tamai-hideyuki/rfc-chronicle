<!DOCTYPE html>
<html lang="ja" data-theme="light">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RFC Chronicle CLI Web UI</title>
    <link rel="stylesheet" href="css/styles.css" />
</head>
<body>
<h1>RFC Chronicle CLI Web UI</h1>

<div>
    <label for="searchInput">æ¤œç´¢ã‚¯ã‚¨ãƒªï¼š</label>
    <input id="searchInput" type="text" placeholder="ä¾‹: HTTP" />
    <button id="searchBtn">ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ¤œç´¢</button>
    <button id="fulltextBtn">å…¨æ–‡æ¤œç´¢</button>
    <button id="semsearchBtn">ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯æ¤œç´¢</button>
    <span id="loading">èª­ã¿è¾¼ã¿ä¸­...</span>
    <span id="error"></span>
</div>

<div id="detailContainer"></div>
<div class="rfc-list" id="resultContainer">
    <p>æ¤œç´¢çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™</p>
</div>
<div id="pagination" class="pagination"></div>

<!-- ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ -->
<button id="themeToggle" class="theme-toggle">ğŸŒ™</button>

<script>
    // DOMã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
    const $ = id => document.getElementById(id);
    const resultContainer = $("resultContainer");
    const detailContainer = $("detailContainer");
    const errorEl         = $("error");
    const loadingEl       = $("loading");
    const paginationEl    = $("pagination");
    const themeToggleBtn  = $("themeToggle");
    const rootEl          = document.documentElement;

    let searchMode   = "metadata";
    let allItems     = [];
    let currentPage  = 1;
    const itemsPerPage = 30;

    const setLoading = flag =>
        loadingEl.style.display = flag ? "inline" : "none";

    // APIãƒ•ã‚§ãƒƒãƒ
    async function apiFetch(path) {
        const res  = await fetch(path, { headers: { "Accept": "application/json" } });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) throw new Error(data.detail || JSON.stringify(data));
        return data;
    }

    // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚µãƒãƒªå–å¾—
    const fetchMetadata = () =>
        fetch("data/metadata_summary.json")
            .then(res => { if (!res.ok) throw new Error(`HTTP ${res.status}`); return res.json(); });

    // å„ç¨®æ¤œç´¢
    const searchMetadata  = q => apiFetch(`/api/search?q=${encodeURIComponent(q)}`).then(r => r.results);
    const searchFulltext  = q => apiFetch(`/api/fulltext?q=${encodeURIComponent(q)}`).then(r => r.results);
    const searchSemsearch = (q, topk = 20) =>
        apiFetch(`/api/semsearch?q=${encodeURIComponent(q)}&topk=${topk}`).then(r => r.results);

    // è©³ç´°è¡¨ç¤º
    async function showRFC(num) {
        const data = await apiFetch(`/api/show/${num}`);
        detailContainer.innerHTML = `
        <button class="close-btn" title="é–‰ã˜ã‚‹">âœ•</button>
        <h2>RFC ${data.number.replace(/\D/g, "")} â€“ ${data.title}</h2>
        <p>
          <strong>Date:</strong> ${data.date}
          &nbsp;
          <strong>Status:</strong> ${data.status}
        </p>
        <pre>${data.body}</pre>
      `;
        detailContainer.style.display = "block";
        detailContainer.querySelector(".close-btn")
            .onclick = () => detailContainer.style.display = "none";
        detailContainer.scrollIntoView({ behavior: "smooth" });
    }

    // ä¸€è¦§æ›´æ–°
    function updateList(items) {
        allItems    = items;
        currentPage = 1;
        renderCurrentPage();
    }

    // ãƒšãƒ¼ã‚¸åˆ†å‰²æç”»
    function renderCurrentPage() {
        const start = (currentPage - 1) * itemsPerPage;
        renderList(allItems.slice(start, start + itemsPerPage));
        renderPagination();
    }

    // ãƒªã‚¹ãƒˆæç”»
    function renderList(items) {
        if (!items?.length) {
            resultContainer.innerHTML = "<p>çµæœãªã—</p>";
            return;
        }
        resultContainer.innerHTML = items.map(item => {
            let num, label;
            if (searchMode === "metadata") {
                if (typeof item === "string") {
                    num   = item.match(/\d+/)[0];
                    label = `RFC ${num}`;
                } else {
                    num   = item.number.replace(/\D/g, "");
                    label = `RFC ${num} â€“ ${item.title}`;
                }
            } else if (searchMode === "fulltext") {
                num   = item.number;
                label = `RFC ${num} â€“ ${item.snippet}`;
            } else {
                num   = item.num;
                label = `RFC ${num} (score: ${item.score.toFixed(4)})`;
            }
            return `<div class="rfc-item" data-rfc="${num}">${label}</div>`;
        }).join("");
    }

    // ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³æç”»
    function renderPagination() {
        const totalPages = Math.ceil(allItems.length / itemsPerPage) || 1;
        if (totalPages <= 1) { paginationEl.innerHTML = ""; return; }

        const windowSize = 10;
        const halfWindow = Math.floor(windowSize / 2);
        let startPage = Math.max(1, currentPage - halfWindow);
        let endPage   = Math.min(totalPages, startPage + windowSize - 1);
        if (endPage - startPage + 1 < windowSize) {
            startPage = Math.max(1, endPage - windowSize + 1);
        }

        let html = "";
        if (currentPage > 1) {
            html += `<button data-page="1">Â« First</button>`;
            html += `<button data-page="${currentPage - 1}">â€¹ Prev</button>`;
        }
        for (let p = startPage; p <= endPage; p++) {
            html += `<button
                  class="${p === currentPage ? 'active' : ''}"
                  data-page="${p}"
                >${p}</button>`;
        }
        if (currentPage < totalPages) {
            html += `<button data-page="${currentPage + 1}">Next â€º</button>`;
            html += `<button data-page="${totalPages}">Last Â»</button>`;
        }
        paginationEl.innerHTML = html;
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¤ãƒ³ãƒ‰
    paginationEl.addEventListener("click", e => {
        if (e.target.tagName !== "BUTTON") return;
        const p = Number(e.target.dataset.page);
        if (!p || p === currentPage) return;
        currentPage = p;
        renderCurrentPage();
    });
    resultContainer.addEventListener("click", e => {
        const el = e.target.closest(".rfc-item");
        if (!el) return;
        errorEl.textContent = "";
        setLoading(true);
        showRFC(el.dataset.rfc)
            .catch(err => errorEl.textContent = `Error: ${err.message}`)
            .finally(() => setLoading(false));
    });

    const doSearch = async fn => {
        const q = $("searchInput").value.trim();
        if (!q) return;
        errorEl.textContent = "";
        detailContainer.style.display = "none";
        setLoading(true);
        try {
            const items = await fn(q);
            updateList(items);
        } catch (err) {
            errorEl.textContent = `Error: ${err.message}`;
        } finally {
            setLoading(false);
        }
    };
    $("searchBtn").onclick    = () => { searchMode = "metadata";  doSearch(searchMetadata); };
    $("fulltextBtn").onclick  = () => { searchMode = "fulltext";  doSearch(searchFulltext); };
    $("semsearchBtn").onclick = () => { searchMode = "semsearch"; doSearch(q => searchSemsearch(q, 20)); };

    // ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆãƒ­ã‚¸ãƒƒã‚¯
    function applyTheme(theme) {
        rootEl.setAttribute("data-theme", theme);
        themeToggleBtn.textContent = theme === "dark" ? "â˜€ï¸" : "ğŸŒ™";
        localStorage.setItem("theme", theme);
    }

    // åˆæœŸãƒ­ãƒ¼ãƒ‰æ™‚ã«ãƒ†ãƒ¼ãƒå¾©å…ƒï¼†ãƒ‡ãƒ¼ã‚¿æç”»
    window.addEventListener("load", async () => {
        // 1) ä¿å­˜ã•ã‚ŒãŸãƒ†ãƒ¼ãƒã‚’å¾©å…ƒ
        const saved = localStorage.getItem("theme") || "light";
        applyTheme(saved);

        // 2) ãã®å¾Œã®æ—¢å­˜ã®åˆæœŸãƒ­ãƒ¼ãƒ‰å‡¦ç†
        setLoading(true);
        try {
            const data = await fetchMetadata();
            updateList(data);
        } catch (err) {
            errorEl.textContent = `Error: ${err.message}`;
        } finally {
            setLoading(false);
        }
    });

    // ãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§ãƒˆã‚°ãƒ«
    themeToggleBtn.addEventListener("click", () => {
        const next = rootEl.getAttribute("data-theme") === "dark" ? "light" : "dark";
        applyTheme(next);
    });

    // åˆæœŸå‡¦ç†
    window.addEventListener("load", async () => {
        // ãƒ†ãƒ¼ãƒå¾©å…ƒ
        const saved = localStorage.getItem("theme") || "light";
        applyTheme(saved);

        setLoading(true);
        try {
            const data = await fetchMetadata();
            updateList(data);
        } catch (err) {
            errorEl.textContent = `Error: ${err.message}`;
        } finally {
            setLoading(false);
        }
    });
</script>
</body>
</html>
